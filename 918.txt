918. Maximum Sum Circular Subarray

#define max(X, Y)  (X > Y ? X : Y)

int maxSubArray(int* nums, int numsSize){
    int m = nums[0], n = m;
    for(int i = 1; i < numsSize; i++) {
        n = max(n + nums[i], nums[i]);
        m = max(n, m);
    }
    return m;
}

int maxSubarraySumCircular(int* nums, int numsSize){
    int sum = 0, linear, circular;
    
    linear = maxSubArray(nums, numsSize);
    for(int i = 0; i < numsSize; i++) {
        sum += nums[i];
        nums[i] *= -1;
    }
    circular = maxSubArray(nums, numsSize) + sum;
    if(circular == 0)
        return linear;
    return max(linear, circular);
}

----------------------------------------------------

* Explain:
The solutions uses "Kadane's algorithm". The function
"maxSubArray" is copied from the previous problem 
"No. 53 Maximum Subarray". 

Use the this figure as a reference
[-----A-----][-----B-----][-----C-----]
A circular solution would mean that the range of 
maximum lost is at B. On the other hand, if is a
linear solution, the maximum 'ost would be either A
or C. So, all we have two do is calcuate two value.
The first value assumes we have a linear solution,
which can be obtained by running the input through
the "maxSubArray" function. The second value 
assumes we have a circular solution. In this case,
we first add up the values in the array to acquire
a sum. Next, reverse the sign in the array and 
run it through the "maxSubArray" function, then 
add the return value with the sum. Lastly, compare
the two solution, the greater one is the answer.

There are cases where every value in the array 
is negative. In this case, we have to at least 
choose 1 of the smallest negative value. The
"if(circular == 0)" is used to account for these
cases.

* Description:
Given a circular integer array nums of length n, 
return the maximum possible sum of a non-empty 
subarray of nums. A circular array means the end 
of the array connects to the beginning of the array.
Formally, the next element of nums[i] is
nums[(i + 1) % n] and the previous element of 
nums[i] is nums[(i - 1 + n) % n]. A subarray may only 
include each element of the fixed buffer nums at most 
once. Formally, for a subarray nums[i], nums[i + 1], 
..., nums[j], there does not exist i <= k1, k2 <= j 
with k1 % n == k2 % n.

